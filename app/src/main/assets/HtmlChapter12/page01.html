 <body>
<h1>Alocarea dinamică a memoriei</h1>

<h2>Pointeri</h2>
<p>Definiție: Un <span class="functions">pointer</span> este o dată a cărei valoare este o adresă de memorie. O variabilă de tip pointer este o variabilă a cărei valoare este adresa altor variabile.</p>
<p>Important: Nu confundați adresa unei variabile cu valoarea memorată de aceasta. Ele sunt de regulă diferite, chiar și în cazul pointerilor!</p>

<h2>Declararea de pointeri</h2>
<p>La declararea unei variabile de tip pointer se precizează tipul variabilelor a căror adrese pot fi memorate de acel pointer:</p>
<p class="codeblock">TIP *<span class="numbers">NUME</span>;<br>
    <span class="comments">// Exemple:</span><br>
    int *<span class="numbers">p</span>;<br>
    <span class="comments">// p este o variabilă de tip pointer a cărei valoare este adresa unei variabile de tip int.</span><br>
    double *<span class="numbers">f</span>;<br>
    <span class="comments">// f este o variabilă de tip pointer a cărei valoare este adresa unei variabile de tip double.</span><br>
    int *<span class="numbers">p</span>, *<span class="numbers">q</span>;<br>
    <span class="comments">// dacă declarăm mai multe variabile de același tip pointer trebuie să plasăm simbolul * înaintea fiecăreia</span>
</p>

<h2>Referențiere, dereferențiere</h2>
<p>adresa unei variabile (statice) poate fi determinată cu ajutorul operatorului de referențiere <span class="functions">&</span>. Fiind o adresă, rezultatul acestei operații poate fi atribuit unui pointer:</p>
<p class="codeblock">
    int <span class="numbers">x</span> , *<span class="numbers">p</span>;<br>
    cout << &<span class="numbers">x</span>; <span class="comments">// adresă</span><br>
    <span class="numbers">p</span> = &<span class="numbers">x</span>;<br>
    cout << <span class="numbers">p</span>; <span class="comments">// aceeași adresă ca mai sus</span>
</p>
<p>variabila cu adresa memorată într-un anumit pointer poate fi obținută cu ajutorul operatorului de dereferențiere *</p>
<p class="codeblock">
    int <span class="numbers">x</span> , *<span class="numbers">p</span>;<br>
    <span class="numbers">x</span> = 7;<br>
    <span class="numbers">p</span> = &<span class="numbers">x</span>; <span class="comments">// x memorează adresa lui x</span><br>
    *<span class="numbers">p</span> = 10; <span class="comments">// dereferențiere: *p este variabila x; s-a modificat x</span><br>
    cout << <span class="numbers">x</span>; <span class="comments">// 10</span>
</p>

<p>la declararea unei variabile de tip pointer, aceasta este inițializată; valoarea ei este 0 sau o adresă la întâmplare; operația de dereferențiere produce de obicei erori de rulare, deoarece valoarea pointerului nu coincide cu adresa unei variabile din zonele de memorie alocate programului curent:</p>
<p class="codeblock">
    int *<span class="numbers">p</span>;<br>
    *<span class="numbers">p</span> = 10; <span class="comments">// eroare la rulare</span>
</p>

<h2>Compararea pointerilor</h2>
<p>În mod curent trebuie să verificăm dacă doi pointeri rețin aceeași adresă. Pentru aceasta putem folosi operatorii == și !=.<br>
<br>
    De asemenea, pointerilor li se pot aplica operatorii relaționali <, >, <=, >=.</p>
<h2>Pointeri la structuri</h2>
<p>Considerăm următoarea secvență:</p>
<p class="codeblock">
    struct <span class="functions">Punct</span><br>{<br>
    &emsp;&emsp;int <span class="numbers">x</span>,<span class="numbers">y</span>;<br>
    };<br>
    <br>
    Punct <span class="numbers">A</span>, *<span class="numbers">pA</span>;<br>
    <span class="numbers">A</span>.<span class="numbers">x</span> = 1, <span class="numbers">A</span>.<span class="numbers">y</span> = 2;<br>
    <span class="numbers">pA</span> = &<span class="numbers">A</span>;<br>
    cout << (*<span class="numbers">pA</span>).<span class="numbers">x</span> << <span class="strings">" "</span> << (*<span class="numbers">pA</span>).<span class="numbers">y</span> << endl;<br>
            cout << <span class="numbers">pA</span>-><span class="numbers">x</span> << <span class="strings">" "</span> << <span class="numbers">pA</span>-><span class="numbers">y</span> << endl;<br>
</p>

<p>Pointerul <span class="numbers">pA</span> memorează adresa variabilei <span class="numbers">A</span>. Observați modul în care s-a făcut accesul la câmpurile variabilei cu adresa în pointerul <span class="numbers">pA</span>:<br>
    <br>
    -în expresia (*<span class="numbers">pA</span>).<span class="numbers">x</span> parantezele rotunde sunt necesare, deoarece operatorul de acces . are prioritate mai mare decât operatorul de dereferențiere *. Fără acestea expresia ar fi fost interpretată astfel: *(pA.x), dar pA nu este o structură cu câmpul x, deci s-ar fi obținut eroare de sintaxă;<br>
        -o altă modalitate, mai simplă, de accesare a câmpurilor structurii cu adresa în pointerul pA constă în folosirea operatorului <span class="numbers">-></span> de acces indirect. În operația p->camp, p trebuie să fie pointer la o structură, iar camp trebuie să fie câmp al acelei structuri.</p>
</body>