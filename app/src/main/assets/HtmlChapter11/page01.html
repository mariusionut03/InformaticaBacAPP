<body>
<h1>Alocarea dinamică a memoriei</h1>

<h2>Pointeri</h2>
<p>Definiție: Un pointer este o dată a cărei valoare este o adresă de memorie. O variabilă de tip pointer este o variabilă a cărei valoare este adresa altor variabile.</p>
<p>Important: Nu confundați adresa unei variabile cu valoarea memorată de aceasta. Ele sunt de regulă diferite, chiar și în cazul pointerilor!</p>

<h2>Declararea de pointeri</h2>
<p>La declararea unei variabile de tip pointer se precizează tipul variabilelor a căror adrese pot fi memorate de acel pointer:</p>
<p class="codeblock">TIP * NUME;<br>
// Exemple:<br>
    int * p;<br>
    // p este o variabilă de tip pointer a cărei valoare este adresa unei variabile de tip int.<br>
    double * f;<br>
    // f este o variabilă de tip pointer a cărei valoare este adresa unei variabile de tip double.<br>
    int *p, *q;<br>
    // dacă declarăm mai multe variabile de același tip pointer trebuie să plasăm simbolul * înaintea fiecăreia
</p>

<h2>Referențiere, dereferențiere</h2>
<p>adresa unei variabile (statice) poate fi determinată cu ajutorul operatorului de referențiere &. Fiind o adresă, rezultatul acestei operații poate fi atribuit unui pointer:</p>
<p class="codeblock">
    int x , * p;
    cout << & x; // adresă
    p = & x;
    cout << p; // aceeași adresă ca mai sus
</p>
<p>variabila cu adresa memorată într-un anumit pointer poate fi obținută cu ajutorul operatorului de dereferențiere *</p>
<p class="codeblock">
    int x , * p;
    x = 7;
    p = & x; // x memorează adresa lui x
    *p = 10; // dereferențiere: *p este variabila x; s-a modificat x
    cout << x; // 10
</p>

<p>la declararea unei variabile de tip pointer, aceasta este inițializată; valoarea ei este 0 sau o adresă la întâmplare; operația de dereferențiere produce de obicei erori de rulare, deoarece valoarea pointerului nu coincide cu adresa unei variabile din zonele de memorie alocate programului curent:</p>
<p class="codeblock">
    int *p;
    *p = 10; // eroare la rulare
</p>

<h2>Compararea pointerilor</h2>
<p>În mod curent trebuie să verificăm dacă doi pointeri rețin aceeași adresă. Pentru aceasta putem folosi operatorii == și !=.<br>
<br>
    De asemenea, pointerilor li se pot aplica operatorii relaționali <, >, <=, >=.</p>
<h2>Pointeri la structuri</h2>
<p>Considerăm următoarea secvență:</p>
<p class="codeblock">
    struct Punct{
    int x,y;
    };

    Punct A, *pA;
    A.x = 1, A.y = 2;
    pA = & A;
    cout << (*pA).x << " " << (*pA).y << endl;
    cout << pA->x << " " << pA->y << endl;
</p>

<p>Pointerul pA memorează adresa variabilei A. Observați modul în care s-a făcut accesul la câmpurile variabilei cu adresa în pointerul pA:<br>
    <br>
    -în expresia (*pA).x parantezele rotunde sunt necesare, deoarece operatorul de acces . are prioritate mai mare decât operatorul de dereferențiere *. Fără acestea expresia ar fi fost interpretată astfel: *(pA.x), dar pA nu este o structură cu câmpul x, deci s-ar fi obținut eroare de sintaxă;<br>
    -o altă modalitate, mai simplă, de accesare a câmpurilor structurii cu adresa în pointerul pA constă în folosirea operatorului -> de acces indirect. În operația p->camp, p trebuie să fie pointer la o structură, iar camp trebuie să fie câmp al acelei structuri.</p>
</body>